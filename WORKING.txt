âœ… WORKING 


ğŸ“Œ This project demonstrates how React apps can handle errors safely using Error Boundaries, 
and how performance can be improved using Suspense + Lazy Loading by loading pages only when required.




ğŸš€ Project Flow (How It Works)


âœ… When App Starts


âœ… Home page loads instantly


âŒ About and Dashboard pages are not loaded initially (because they are lazy loaded)


ğŸ“Œ This improves initial app loading speed.


âœ… When user clicks About


About component loads dynamically


Suspense shows a Loader while the page is loading


Once loaded, About page is displayed


âœ… When user clicks Dashboard


Dashboard component loads dynamically


Suspense shows Loader until Dashboard loads


API call happens inside Dashboard


Users list is displayed


ğŸ“Œ API errors are handled using try/catch.






âœ… When user clicks BuggyPage


BuggyPage contains an intentional error (null.name)

BuggyPage crashes

ErrorBoundary catches the crash

Instead of breaking the whole app, it displays fallback UI:

âš  Something went wrong!

ğŸ“Œ Only BuggyPage fails, other pages still work because ErrorBoundary is applied route-wise.









ğŸ›¡ ErrorBoundary Component Explanation

ğŸ“Œ ErrorBoundary is a special React Class Component used to catch UI crashes.

It prevents the entire app from crashing if a component throws an error during rendering.

Instead, it shows a fallback UI.







âœ… 1) Why Class Component?

ğŸ“Œ Error Boundaries work only in Class Components.
Thatâ€™s why we create ErrorBoundary like this:

class ErrorBoundary extends React.Component



â€œGuys, before React Hooks were introduced, most React components were written using Class Components.
Even today, React has one special feature that still requires a class component â€” that is the Error Boundary.
So if we want to catch UI crashes and show a fallback UI instead of breaking the full app, we must use a Class Component.â€



âœ… Why does React require Class Component?

Because Error Boundaries depend on special lifecycle methods such as:

getDerivedStateFromError()

componentDidCatch()

ğŸ“Œ These lifecycle methods are available only in Class Components, not in Functional Components.




âœ… What are Lifecycle Methods?

ğŸ“Œ Lifecycle methods are special functions in Class Components that React automatically runs during different stages of a componentâ€™s life.

A component has 3 major lifecycle stages:

1ï¸âƒ£ Mounting

(Component is created and shown for the first time)

2ï¸âƒ£ Updating

(Component re-renders when state/props change)

3ï¸âƒ£ Unmounting

(Component is removed from the screen)

ğŸ“Œ Lifecycle methods help React manage these stages properly.




âœ… Lifecycle in Functional Components

Functional components do not use lifecycle methods directly.
Instead, they use React Hooks.



ğŸ”¥ Example:

âœ… Class Component Lifecycle Methods:

componentDidMount()

componentDidUpdate()

componentWillUnmount()


âœ… Functional Component Alternative:

useEffect() can handle all these lifecycle behaviors.



ğŸ“Œ Class Components use Lifecycle Methods
ğŸ“Œ Functional Components use Hooks (useEffect)









âœ… 2) State for tracking error

this.state = {
  hasError: false,
};


ğŸ“Œ Meaning:

Initially, no error exists.

If an error occurs, we update hasError = true.









âœ… 3) getDerivedStateFromError()
static getDerivedStateFromError(error) {
  return { hasError: true };
}


ğŸ“Œ Meaning:

When any child component crashes, React automatically calls this method.

It updates the state so React knows to show fallback UI.










âœ… 4) componentDidCatch()
componentDidCatch(error, info) {
  console.error("Error Caught in ErrorBoundary:", error);
  console.error("Component Info:", info);
}


ğŸ“Œ Meaning:
This method runs after an error occurs.

It is mainly used for:

Logging errors

Debugging

Sending errors to monitoring tools like Sentry

âœ… Sentry = Online bug tracking / crash reporting tool for production apps.









âœ… 5) render() decides output

if (this.state.hasError) {
  return <FallbackUI />;
}

return this.props.children;


ğŸ“Œ Meaning:

If error happens â†’ show fallback UI

If no error â†’ show the actual child component









ğŸ”¥ What is this.props.children?

It represents the component wrapped inside ErrorBoundary.

Example:

<ErrorBoundary>
  <BuggyPage />
</ErrorBoundary>


Here, BuggyPage is the children.

So ErrorBoundary protects it.








ğŸ¯ Summary 

âœ… ErrorBoundary is like a safety shield.
If a component crashes, React will not break the whole app.
Instead, it shows a fallback UI.






âš¡ What ErrorBoundary Can and Cannot Catch

âœ… It catches:

Rendering errors

Lifecycle method errors

âŒ It does NOT catch:

API errors (fetch/axios)

async errors

event handler errors

ğŸ“Œ Thatâ€™s why API errors must be handled using try/catch.